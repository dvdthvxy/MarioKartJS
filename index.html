<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <link rel="stylesheet" href="styles/style.css">
    <title>Document</title>
</head>

<body>
    <div id="hud">
        <div id="timer">
            1:00
        </div>
        <div id="item">

        </div>
        <div id="coins">
            x0
        </div>
    </div>
    <div class="border">
        <canvas id="game-screen" data-position="px"></canvas>
    </div>

    <script>
        let mario
        let walls
        let coins
        let checkpoints
        let timer
        // let.cameraX = -825
        // let cameraY = 200
        let rotateDeg = 0
        let id = 0

        const game = {
            canvas: document.getElementById('game-screen'),
            start() {
                this.canvas.width = 700;
                this.canvas.height = 700;
                this.context = this.canvas.getContext("2d");
                this.interval = setInterval(updateGame, 20);
                this.keys = []
                this.cameraX = -825
                this.cameraY = 200
                window.addEventListener('keydown', handleKeydown)
                window.addEventListener('keyup', handleKeyUp)
            },
            clear() {
                this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
            }
        }

        class Wall {
            constructor(width, height, x, y) {
                this.width = width;
                this.height = height;
                this.x = x;
                this.y = y;
                this.color = 'transparent';
            }
            // update() {
            //     const ctx = game.context;
            //     ctx.fillStyle = this.color;
            //     ctx.fillRect(this.x, this.y, this.width, this.height);
            // }
        }

        Wall.prototype.update = function () {
            const ctx = game.context;
            ctx.fillStyle = this.color;
            ctx.fillRect(this.x, this.y, this.width, this.height);
        }

        // class Player extends Wall {
        class Player {
            constructor(width, height, img, x, y) {
                // super()
                this.width = width;
                this.height = height;
                this.image = new Image()
                this.image.src = img
                this.x = x;
                this.y = y;
                this.angle = 0
                this.moveAngle = 0
                this.speed = 0
                this.acceleration = 0.1
                this.topSpeed = 3
            }
            update() {
                const ctx = game.context;
                ctx.save();
                ctx.translate(this.x, this.y)
                ctx.rotate(this.angle)
                ctx.drawImage(this.image, this.width / -2, this.height / -2, this.width, this.height)
                ctx.restore()
            }
            newPos() {
                if (this.speed > 0) {
                    this.speed -= 0.05
                } else if (game.keys[40]) {
                    this.reverse()
                } else {
                    this.speed = 0
                }
                this.angle += this.moveAngle * Math.PI / 180;
                rotateDeg = this.angle
                this.x += this.speed * Math.sin(this.angle);
                game.cameraX -= (this.speed * Math.sin(this.angle)) * 3;
                this.y -= this.speed * Math.cos(this.angle);
                game.cameraY += (this.speed * Math.cos(this.angle)) * 3;
                this.left = this.x - (this.width / 2);
                this.right = this.x + (this.width / 2);
                this.top = this.y - (this.height / 2);
                this.bottom = this.y + (this.height / 2);
                game.canvas.style.setProperty(`--xPlayer`, this.x + "px");
                game.canvas.style.setProperty(`--yPlayer`, this.y + "px");
                game.canvas.style.setProperty(`--xPos`, game.cameraX + "px");
                game.canvas.style.setProperty(`--yPos`, (game.cameraY - 300) + "px");
                game.canvas.style.setProperty(`--turn`, (rotateDeg * 180) + "deg");
            }
            collidesWith(otherObj) {
                const objLeft = otherObj.x;
                const objRight = otherObj.x + (otherObj.width);
                const objTop = otherObj.y;
                const objBottom = otherObj.y + (otherObj.height);
                let crash = true;

                if ((this.bottom < objTop) ||
                    (this.top > objBottom) ||
                    (this.right < objLeft) ||
                    (this.left > objRight)) {
                    return !crash;
                }
                return crash
            }
            bounceBackFrom(obj) {
                const objLeft = obj.x;
                const objRight = obj.x + (obj.width);
                const objTop = obj.y;
                const objBottom = obj.y + (obj.height);
                const bounce = 0.5

                this.speed = 0
                if (this.top < objBottom && (this.left > objLeft || this.right < objRight) && this.bottom > objBottom) {
                    console.log('top collided')
                    this.y += bounce
                    game.cameraY -= 1.5
                }

                if (this.left < objRight && (this.top > objTop && this.bottom < objBottom) && this.left > objLeft) {
                    console.log("left collided")
                    this.x += bounce
                    game.cameraX -= 1.5
                }

                if (this.right > objLeft && (this.top > objTop && this.bottom < objBottom) && this.right < objRight) {
                    console.log("right collided")
                    this.x -= bounce
                    game.cameraX += 1.5
                }

                if (this.bottom > objTop && (this.left > objLeft || this.right < objRight) && this.top < objTop) {
                    this.y -= bounce
                    game.cameraY += 1.5
                }
            }
            collect(coin) {
                coin.isCollected = true
                this.topSpeed += 0.25
            }
            accelerate() {
                if (this.speed < this.topSpeed) {
                    this.speed += this.acceleration
                } else {
                    this.speed = this.topSpeed
                }
            }
            turnLeft() {
                this.moveAngle = -3
            }
            turnRight() {
                this.moveAngle = 3
            }
            reverse() {
                if (this.speed > 0) {
                    this.speed -= 0.05
                } else {
                    this.speed = -0.5
                }
            }
        }

        // class Coin extends Wall {
        class Coin {
            constructor(x, y, color) {
                // super()
                this.width = 5;
                this.height = 5;
                this.color = color;
                this.x = x;
                this.y = y;
                this.isCollected = false;
            }
            update() {
                if (!(this.isCollected)) {
                    const ctx = game.context;
                    ctx.fillStyle = this.color;
                    ctx.fillRect(this.x, this.y, this.width, this.height);
                }
            }
        }

        class Checkpoint extends Wall {
            constructor(width, height, x, y, id) {
                super()
                this.width = width
                this.height = height
                this.color = 'transparent'
                this.x = x
                this.y = y
                this.id = id
                this.isPassed = false
            }
        }

        class Timer {
            constructor() {
                this.context = document.getElementById("timer")
                this.startTime = new Date
                this.startingLapTime = new Date
                this.lapTimes = []
                this.elapsedTime = {}
            }
            update() {
                this.currentTime = new Date
                this.elapsedTime.totalTime = this.currentTime - this.startTime
                this.elapsedTime.currentLapTime = this.currentTime - this.startingLapTime
                this.context.innerHTML = this.getMinutes(this.elapsedTime.totalTime) + ":" + ("0" + this.getSeconds(this.elapsedTime.totalTime)).slice(-2) + "." + ("0" + this.getMilliseconds(this.elapsedTime.totalTime)).slice(-2)
            }
            getMinutes(totalTime) {
                return Math.floor(totalTime / 60000)
            }
            getSeconds(totalTime) {
                return Math.floor((totalTime - (this.getMinutes(totalTime) * 60000)) / 1000)
            }
            getMilliseconds(totalTime) {
                return Math.floor((totalTime - (this.getMinutes(totalTime) * 60000) - (this.getSeconds(totalTime) * 1000)) / 10)
            }
        }

        function observeNextCheckpoint(checkpoint) {
            checkpoint.isPassed = true
            if (id < checkpoints.length - 1) {
                id++
            } else {
                id = 0
            }
        }

        function resetCheckpoints(checkpointsArray) {
            checkpointsArray = checkpointsArray.map(checkpoint => {
                checkpoint.isPassed = false
                return checkpoint
            })
        }

        function updateGame() {
            game.clear()
            timer.update()
            mario.moveAngle = 0;
            checkInput(game.keys)
            mario.newPos()
            mario.update()
            walls.forEach(wall => wall.update())
            coins.forEach(coin => coin.update())
            checkpoints.forEach(checkpoint => checkpoint.update())
            walls.forEach(wall => {
                if (mario.collidesWith(wall)) {
                    // bounceBackFrom(wall, mario)
                    mario.bounceBackFrom(wall)
                }
            });
            coins.forEach(coin => {
                if (mario.collidesWith(coin) && !(coin.isCollected)) {
                    mario.collect(coin)
                }
            })

            if (mario.collidesWith(checkpoints[id]) && !(checkpoints[id].isPassed)) {
                observeNextCheckpoint(checkpoints[id])
            }

            if (checkpoints.every(checkpoint => checkpoint.isPassed)) {
                resetCheckpoints(checkpoints)
                timer.lapTimes.push(timer.elapsedTime.currentLapTime)
                console.log(timer.lapTimes)
                timer.startingLapTime = new Date
            }
        }

        function checkInput(keys) {
            if (keys && keys[37]) {
                mario.turnLeft()
            }
            if (keys && keys[39]) {
                mario.turnRight()
            }
            if (keys && keys[38]) {
                mario.accelerate()
            }
        }
        //"assets/snesMario.png"
        function startGame() {
            game.start()
            mario = new Player(15, 15, "assets/snesMario (1).png", 629, 400)

            walls = [new Wall(55, 200, 525, 153),
            new Wall(432, 10, 148, 350),
            new Wall(131, 16, 126, 93),
            new Wall(50, 192, 104, 103),
            new Wall(25, 140, 503, 219),
            new Wall(8, 80, 147, 275),
            new Wall(22, 267, 350, 0),
            new Wall(431, 18, 0, 420),
            new Wall(54, 28, 400, 426),
            new Wall(38, 18, 125, 563),
            new Wall(38, 18, 147, 552),
            new Wall(38, 18, 169, 541),
            new Wall(38, 18, 191, 530),
            new Wall(38, 18, 213, 519),
            new Wall(213, 8, 213, 519),
            new Wall(158, 8, 422, 527),
            new Wall(8, 180, 573, 355),
            new Wall(6, 22, 350, 590),
            new Wall(6, 65, 350, 635),
            new Wall(7, 700, 0, 0),
            new Wall(7, 700, 694, 0),
            new Wall(700, 7, 0, 0),
            new Wall(700, 7, 0, 694)]

            coins = [new Coin(625, 200, 'yellow'),
            new Coin(650, 200, 'yellow')]

            checkpoints = [new Checkpoint(105, 1, 585, 200, 0),
            new Checkpoint(1, 145, 555, 7, 1),
            new Checkpoint(125, 1, 375, 250, 2),
            new Checkpoint(190, 1, 155, 200, 3),
            new Checkpoint(1, 85, 175, 7, 4),
            new Checkpoint(90, 1, 10, 200, 5),
            new Checkpoint(1, 55, 250, 364, 6),
            new Checkpoint(110, 1, 460, 440, 7),
            new Checkpoint(1, 75, 250, 440, 8),
            new Checkpoint(110, 1, 10, 575, 9),
            new Checkpoint(1, 150, 352, 530, 10),
            new Checkpoint(105, 1, 585, 530, 11),
            new Checkpoint(105, 1, 585, 382, 12)]

            timer = new Timer()
        }

        function handleKeydown(e) {
            game.keys[e.keyCode] = true
        }

        function handleKeyUp(e) {
            game.keys[e.keyCode] = false
        }

        document.addEventListener('DOMContentLoaded', () => {
            startGame()
        })
    </script>
</body>

</html>